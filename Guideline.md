# ガイドライン

## 1. 目次

- [ガイドライン](#)
	- [1. 目次](#1-目次)
	- [2. 課題内容](#2-課題内容)
	- [3. ネットワークモデル](#3-ネットワークモデル)
		- [3.1. ユーザ端末](#31-ユーザ端末)
		- [3.2. 管理用端末](#32-管理用端末)
		- [3.3. VMマネージャ](#33-vmマネージャ)
		- [3.4. コンテナ](#34-コンテナ)
		- [3.5. スイッチ](#35-スイッチ)
		- [3.6. コントローラ](#36-コントローラ)
	- [4. ユーザ端末](#4-ユーザ端末)
		- [4.1. コンテナの利用開始要求](#41-コンテナの利用開始要求)
		- [4.2. コンテナの利用停止要求](#42-コンテナの利用停止要求)
		- [4.3. コンテナの利用状況確認要求](#43-コンテナの利用状況確認要求)
	- [5. 管理用端末](#5-管理用端末)
		- [5.1. 更新方法](#51-更新方法)
		- [5.2. Rest APIの実行](#52-rest-apiの実行)
	- [6. VMマネージャ](#6-vmマネージャ)
		- [6.1. 構成](#61-構成)
		- [6.2. Rest API](#62-rest-api)
		- [6.3. VM利用開始処理](#63-vm利用開始処理)
			- [6.3.1. VM利用開始要求時のシーケンス図](#631-vm利用開始要求時のシーケンス図)
		- [6.4. VM利用停止処理](#64-vm利用停止処理)
		- [6.5. VM利用状況確認処理](#65-vm利用状況確認処理)
		- [6.6. Rest APIの実行](#66-rest-apiの実行)
	- [7. コントローラ](#7-コントローラ)
		- [7.1. ルーティング処理の追加](#71-ルーティング処理の追加)
		- [7.2. Rest API](#72-rest-api)
	- [8. IPアドレスの割当](#8-ipアドレスの割当)

## 2. 課題内容

簡易的なIaaSを作成しなさい． ただし，以下のことができるように実装すること．

1. 指定したVMイメージを台数分立ち上げる
2. プライベートNWを作ってインターネットに接続する

## 3. ネットワークモデル

本課題においては， スイッチから成るネットワーク（以下**スイッチネットワーク**）をインターネットとみなし， 以下のノードから構成されるネットワークモデルを考える．

- エンドユーザ端末（以下ユーザ端末）
- 管理用端末
- スイッチ
- コントローラ
- VMマネージャ
- コンテナ

![overview image](https://github.com/handai-trema/IaaS-amn/blob/develop/picture/aaa.png?raw=true)



ユーザ端末，管理用端末及びVMマネージャはそれぞれスイッチネットワークに接続されており， このスイッチネットワークを介してのみ通信が可能である．

また，コンテナはVMマネージャの管理下に設置されるものとする．

### 3.1. ユーザ端末

ユーザ端末はスイッチネットワークを介して 他端末と通信することができる．

ただし，通信時には宛先のIPアドレスを知っている必要があるため， VMマネージャ及びVMマネージャからIPを通知されたコンテナとしか通信できない． （他のユーザ端末や管理用端末，スイッチのコントローラとは通信できない）

VMマネージャに対し，Rest APIを通して， コンテナの割当て要求，割当て解除要求，割当て確認要求（これらをコンテナ管理要求とする）の送信及びそれらの結果の受信を行う．

### 3.2. 管理用端末

管理用端末はスイッチと接続されることで， スイッチネットワークを介して他端末と通信することができる．

ネットワークを管理するための端末であり， スイッチのコントローラ及びVMマネージャと通信できる．

また，Webインターフェース及びRest APIを通してコントローラと通信し， ユーザ端末，スイッチ及びVMを含めたスライス/トポロジの状態を確認することができる．

### 3.3. VMマネージャ

VMマネージャは，スイッチネットワークを介して 他端末と通信することができる．

VMマネージャは，コンテナの管理を行うための機能及びその機能を持つサーバそのものであり， コンテナ自体もこのサーバ内部に設置される．

Rest APIを通してコントローラと通信することができ， コンテナ管理要求を送信したユーザ端末，要求内容及び関連するコンテナの情報をもとに ネットワークスライスの構築及び削除を要求することができる．

コンテナの管理にはDockerを利用している

### 3.4. コンテナ

IPアドレスが設定された，VMマネージャ内に設置された端末である．

### 3.5. スイッチ

スイッチは，スイッチ同士で相互に接続することでネットワークを構成する． それぞれのスイッチはL3転送に対応し，パケットヘッダにおけるMACアドレスの書き換えが可能な**ルータ**として動作する．

また，コントローラからFlowModやPacketOutを受け取り，フローテーブルの内容を変更することで スライス内通信を実現させている．

### 3.6. コントローラ

コントローラは，各スイッチと接続されており， OpenFlowのメッセージを用いてスイッチに指示を与えることができる．

トポロジ情報，スライス情報を管理しており， Rest APIを用いて管理用端末に対しこれらの情報を開示することができる．


## 4. ユーザ端末

ユーザ用WebインターフェースはWebページとして実装され，コマンドを送信するためのボタンをクリックすることでVMマネージャにコンテナ管理要求を送信する．

コマンドボタンには以下の4つが存在する．

- run: コンテナの利用開始要求を送信する．フォームにコンテナの台数を設定することで指定した台数を利用するための要求を送信できる．
- stop: コンテナの利用停止要求を送信する．
- show: コンテナの利用状況確認要求を送信する．
- help: amncliコマンドの説明を表示する．

ボタンの押下によってRest APIを実行することができる．

### 4.1. コンテナの利用開始要求

[VMマネージャの制御用IP]/api/run/で表されるURIに対し，</vmマネージャのip>

```
{"client": <ユーザ端末のIPアドレス>,"number": <利用するVM台数>}
```

で表されるJSONをHTTP POSTメソッドによって送信する．

### 4.2. コンテナの利用停止要求

[vmマネージャの制御用IP]/api/stop/で表されるURIに対し，</vmマネージャのip>

```
{"client": <ユーザ端末のIPアドレス>}
```

で表されるJSONをHTTP POSTメソッドによって送信する．

### 4.3. コンテナの利用状況確認要求

[VMマネージャの制御用IP]/api/show/で表されるURIに対し，

```
{"client": <ユーザ端末のIPアドレス>}
```

で表されるJSONをHTTP POSTメソッドによって送信する．

## 5. 管理用端末

Webインターフェースは簡易なHTMLファイルで実装され， 更新ボタンを押下することで現在のトポロジ情報及びスライス状態を表示する．

### 5.1. 更新方法

Webインターフェース内に更新ボタンを配置し， これをクリックすることでコントローラに状態表示要求を行う（詳細は「Rest APIの実行」を参照）．

### 5.2. Rest APIの実行

[コントローラのIP]/api/status/で表されるURIに対し， HTTP GETメソッドによって状態表示を要求する．

結果としてコントローラからは トポロジ及びスライスの状態を表示するhtmlファイルが返される．

※htmlのformタグなどで実装．

## 6. VMマネージャ

VMマネージャはユーザ端末からコンテナ管理要求を受け取り，指定された処理を実行し，結果を返す． また， コンテナの状態が変更されたことによりスライスの変更が必要な場合はコントローラへ通知を行う．

### 6.1. 構成

VMマネージャは外部につながるインターフェースを2つ持つ． 1つは，VMマネージャ自身がユーザ端末やコントローラと通信するための制御用インターフェース， もう1つは，VMマネージャの機能により設置されたVMとネットワークをつなぐデータ用インターフェースである．

制御用インターフェース側にVMマネージャのIPアドレスが設定されており， データ用インターフェース側はIPアドレスの設定を行わない． ただし，データ用インターフェースは内部のブリッジと接続されており，そのブリッジはIPアドレスを持つ．

※データ用インターフェースに関しては，他端末（コンテナ）宛てのパケットを受け取るため，VBのネットワークアダプタ設定でプロミスキャスの項目を「すべて許可」にしておく必要がある．

また，VMマネージャはクライアントとなるユーザ端末と，クライアントが利用しているVM及びそれらの端末が属するスライスの対応を保持している． 対応は以下のようなエントリを持つテーブル（VMテーブルとする）として所持しておく．

```
<entry> = <clientIP>, <VM IP list>, <slice>
```

※実装上は連想配列だろうとクラス作って配列にしようとなんでも構いません

### 6.2. Rest API

VMマネージャは，ユーザ端末からRest APIを通してコンテナ管理要求を受け取る． 受信するJSONメッセージの構成は前節を参照のこと．

受信した要求の種類により， VM利用開始処理，VM利用停止処理，VM利用状況確認処理を実行する．

### 6.3. VM利用開始処理

受け取ったJSONメッセージから， "client"と"num"というオブジェクトを受け取る．

"num"オブジェクトで指定された台数のVMを立ち上げ，それぞれのIPアドレスを設定し， そのリストを1行に1つのIPという形式で ユーザ端末へ実行結果を返す．

```
---------
status: running
client: 192.168.1.200
vm list:
1 192.168.1.100
2 192.168.1.101
3 192.168.1.102
---------
```

ここで "client"オブジェクトで指定されたユーザ端末及び本処理で追加されたコンテナについては プライベートネットワークの構成ノードとなるため， 新たなスライスを設定する必要がある．

そのため， Rest APIを利用してコントローラと通信することで新たなスライスを作成し， クライアントおよびコンテナを同一スライスに追加する（「Rest APIの実行」項を参照のこと）．

その後，クライアントのIP，コンテナのIPリスト，スライス名を対応付けてVMテーブルに格納する．

#### 6.3.1. VM利用開始要求時のシーケンス図

ユーザ端末がVM利用開始要求を行った時のシーケンス図は以下の通りである。

![overview image](https://github.com/handai-trema/IaaS-amn/blob/develop/picture/sequence_VMdemand.png?raw=true)


### 6.4. VM利用停止処理

受け取ったJSONメッセージから クライアントのIPアドレスを"client"オブジェクトから受け取る．

VMテーブルの中からクライアントのIPアドレスに一致する項目を探索し， クライアントおよびVMリスト内のコンテナを Rest APIの実行によってスライスから削除するようコントローラに指示する． さらに，これらが属していたスライスの削除も同様にコントローラに指示する．

終了後，該当エントリをVMテーブルから削除し， 結果をユーザ端末に返す． 実行結果は以下のようなフォーマットとする．

```
---------
status: ended
client: 192.168.1.200
vm list:
1 192.168.1.100
2 192.168.1.101
3 192.168.1.102
---------
```

### 6.5. VM利用状況確認処理

受け取ったJSONメッセージから クライアントのIPアドレスを"client"オブジェクトから受け取る．

VMテーブルの中からクライアントのIPアドレスに一致する項目を探索し， コンテナのIPリストを結果として返す． 実行結果は以下のようなフォーマットとする．

```
---------
status: running
client: 192.168.1.200
vm list:
1 192.168.1.100
2 192.168.1.101
3 192.168.1.102
---------
```

### 6.6. Rest APIの実行

VMマネージャは，コンテナの追加及び削除によってスライスの構成が変更される場合に， コントローラへ指示を行う．

この指示はRest APIを通して行われる． ただし，このときのURIやJSONの仕様については前回課題（スライス）のものを利用することとする．

結果としてコントローラからは スライス情報更新完了のメッセージが返される．

## 7. コントローラ

コントローラはVMマネージャからスライスに関する命令を受け取り， スライス及びスライスへのホストの追加/削除を行う．

また，経路選択やトポロジ形成，IPアドレスを利用したパケット転送を行うためのFlowMod/PacketOutをスイッチに送信する．

ただし， スライスに追加するホストの情報に関しては， MACアドレスを格納していた前回課題とは異なり， IPアドレスを格納する．

また，前回課題で生成していたトポロジ/スライス状態を表示したHTMLファイルについては 管理用Webインターフェース内に設置するボタンも配置することとする．

※こうしないと，一回更新ボタン押したら，ブラウザバックしないと更新できなくなる

### 7.1. ルーティング処理の追加

前回課題においては，スイッチはL2のスイッチとして実装されており， IPアドレスに基づくパケット転送ができない．

そのため，ルーティングスイッチのコードを参考に L3のルータとしての機能を追加する必要がある． （このとき，送信元/宛先IPアドレスはパケットが宛先に届くまで保持され，送信元/宛先MACアドレスはスイッチを経由するたびに書き換えられる）

### 7.2. Rest API

Rest APIについては前回課題と同じ仕様を用いる．

追加の仕様として， [コントローラのIP]/api/status/で表されるURIで 管理用端末から受け取ったGETメッセージに対しては 前回課題で出力していたトポロジ/スライス状態を表示したHTMLファイルを返す．

## 8. IPアドレスの割当

各機器に割当てられるIPアドレスを以下に示す。

更新版

| 機器         |                    IP アドレス |                    実ホスト |
|:-------------|-------------|-------------------------------:|
| スイッチ     |                    192.168.1.1 ||
| VMマネージャ1 |     192.168.1.2 〜 192.168.1.3 |阿部君のPCで実現(192.168.1.249)|
| VMマネージャ2 |   192.168.1.4 〜 192.168.1.5  |佐竹君のPCで実現(192.168.1.248)|
| Webサーバー |                  192.168.1.6/24 |錦織君のPCで実現(192.168.1.250)|
| 管理用端末   |    192.168.1.7 〜 192.168.1.9 ||
| VM           |  192.168.1.10 〜 192.168.1.199 ||
| ユーザ端末   | 192.168.1.200 〜 192.168.1.232 ||
| other        | 192.168.1.233 〜 192.168.1.250 ||
| コントローラ |     192.168.1.251 〜 192.168.1.254 ||
|



変更前
| 機器         |                    IP アドレス |
|:-------------|-------------------------------:|
| スイッチ     |                    192.168.1.1 |
| VMマネージャ |     192.168.1.2 〜 192.168.1.3 |
| 管理用端末   |     192.168.1.4 〜 192.168.1.9 |
| VM           |  192.168.1.10 〜 192.168.1.199 |
| ユーザ端末   | 192.168.1.200 〜 192.168.1.232 |
| other        | 192.168.1.233 〜 192.168.1.253 |
| コントローラ |                  192.168.1.254 |

